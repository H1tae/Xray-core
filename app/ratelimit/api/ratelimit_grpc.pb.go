// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.1
// source: app/ratelimit/api/ratelimit.proto

package ratelimitpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RateLimitService_SetUserDefaultPerConnLimit_FullMethodName   = "/ratelimit.v1.RateLimitService/SetUserDefaultPerConnLimit"
	RateLimitService_ListUserConnections_FullMethodName          = "/ratelimit.v1.RateLimitService/ListUserConnections"
	RateLimitService_SetConnectionLimit_FullMethodName           = "/ratelimit.v1.RateLimitService/SetConnectionLimit"
	RateLimitService_ClearConnectionLimit_FullMethodName         = "/ratelimit.v1.RateLimitService/ClearConnectionLimit"
	RateLimitService_GetActiveDevicesSnapshot_FullMethodName     = "/ratelimit.v1.RateLimitService/GetActiveDevicesSnapshot"
	RateLimitService_PeekActiveDevicesSnapshot_FullMethodName    = "/ratelimit.v1.RateLimitService/PeekActiveDevicesSnapshot"
	RateLimitService_ListUserDevices_FullMethodName              = "/ratelimit.v1.RateLimitService/ListUserDevices"
	RateLimitService_SetDeviceLimit_FullMethodName               = "/ratelimit.v1.RateLimitService/SetDeviceLimit"
	RateLimitService_ClearDeviceLimit_FullMethodName             = "/ratelimit.v1.RateLimitService/ClearDeviceLimit"
	RateLimitService_SetUserTotalLimit_FullMethodName            = "/ratelimit.v1.RateLimitService/SetUserTotalLimit"
	RateLimitService_GetUserStats_FullMethodName                 = "/ratelimit.v1.RateLimitService/GetUserStats"
	RateLimitService_SetKeyMode_FullMethodName                   = "/ratelimit.v1.RateLimitService/SetKeyMode"
	RateLimitService_GetKeyMode_FullMethodName                   = "/ratelimit.v1.RateLimitService/GetKeyMode"
	RateLimitService_SetGrace_FullMethodName                     = "/ratelimit.v1.RateLimitService/SetGrace"
	RateLimitService_GetGrace_FullMethodName                     = "/ratelimit.v1.RateLimitService/GetGrace"
	RateLimitService_ClearUserEgressCache_FullMethodName         = "/ratelimit.v1.RateLimitService/ClearUserEgressCache"
	RateLimitService_ClearUserDefaultPerConnLimit_FullMethodName = "/ratelimit.v1.RateLimitService/ClearUserDefaultPerConnLimit"
	RateLimitService_ClearUserConnOverrideLimits_FullMethodName  = "/ratelimit.v1.RateLimitService/ClearUserConnOverrideLimits"
)

// RateLimitServiceClient is the client API for RateLimitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RateLimitServiceClient interface {
	// ---- existing (оставим для отладки/совместимости) ----
	SetUserDefaultPerConnLimit(ctx context.Context, in *SetUserDefaultPerConnLimitRequest, opts ...grpc.CallOption) (*SetUserDefaultPerConnLimitResponse, error)
	ListUserConnections(ctx context.Context, in *ListUserConnectionsRequest, opts ...grpc.CallOption) (*ListUserConnectionsResponse, error)
	SetConnectionLimit(ctx context.Context, in *SetConnectionLimitRequest, opts ...grpc.CallOption) (*SetConnectionLimitResponse, error)
	ClearConnectionLimit(ctx context.Context, in *ClearConnectionLimitRequest, opts ...grpc.CallOption) (*ClearConnectionLimitResponse, error)
	// Снимок всех активных "устройств" (uuid+src_ip) на ЭТОМ сервере.
	GetActiveDevicesSnapshot(ctx context.Context, in *GetActiveDevicesSnapshotRequest, opts ...grpc.CallOption) (*GetActiveDevicesSnapshotResponse, error)
	PeekActiveDevicesSnapshot(ctx context.Context, in *GetActiveDevicesSnapshotRequest, opts ...grpc.CallOption) (*GetActiveDevicesSnapshotResponse, error)
	// Список устройств конкретного пользователя (uuid) на ЭТОМ сервере.
	ListUserDevices(ctx context.Context, in *ListUserDevicesRequest, opts ...grpc.CallOption) (*ListUserDevicesResponse, error)
	// Управление лимитом по "устройству" (device_key = uuid + "|" + src_ip).
	SetDeviceLimit(ctx context.Context, in *SetDeviceLimitRequest, opts ...grpc.CallOption) (*SetDeviceLimitResponse, error)
	ClearDeviceLimit(ctx context.Context, in *ClearDeviceLimitRequest, opts ...grpc.CallOption) (*ClearDeviceLimitResponse, error)
	// Установить ОБЩИЙ лимит для пользователя (UUID).
	// Лимит будет РАВНОМЕРНО поделен между всеми активными устройствами
	// этого UUID на данном сервере.
	SetUserTotalLimit(ctx context.Context, in *SetUserTotalLimitRequest, opts ...grpc.CallOption) (*SetUserTotalLimitResponse, error)
	GetUserStats(ctx context.Context, in *GetUserStatsRequest, opts ...grpc.CallOption) (*GetUserStatsResponse, error)
	SetKeyMode(ctx context.Context, in *SetKeyModeRequest, opts ...grpc.CallOption) (*SetKeyModeResponse, error)
	GetKeyMode(ctx context.Context, in *GetKeyModeRequest, opts ...grpc.CallOption) (*GetKeyModeResponse, error)
	SetGrace(ctx context.Context, in *SetGraceRequest, opts ...grpc.CallOption) (*SetGraceResponse, error)
	GetGrace(ctx context.Context, in *GetGraceRequest, opts ...grpc.CallOption) (*GetGraceResponse, error)
	ClearUserEgressCache(ctx context.Context, in *ClearUserEgressCacheRequest, opts ...grpc.CallOption) (*ClearUserEgressCacheResponse, error)
	ClearUserDefaultPerConnLimit(ctx context.Context, in *ClearUserDefaultPerConnLimitRequest, opts ...grpc.CallOption) (*ClearUserDefaultPerConnLimitResponse, error)
	ClearUserConnOverrideLimits(ctx context.Context, in *ClearUserConnOverrideLimitsRequest, opts ...grpc.CallOption) (*ClearUserConnOverrideLimitsResponse, error)
}

type rateLimitServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRateLimitServiceClient(cc grpc.ClientConnInterface) RateLimitServiceClient {
	return &rateLimitServiceClient{cc}
}

func (c *rateLimitServiceClient) SetUserDefaultPerConnLimit(ctx context.Context, in *SetUserDefaultPerConnLimitRequest, opts ...grpc.CallOption) (*SetUserDefaultPerConnLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserDefaultPerConnLimitResponse)
	err := c.cc.Invoke(ctx, RateLimitService_SetUserDefaultPerConnLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ListUserConnections(ctx context.Context, in *ListUserConnectionsRequest, opts ...grpc.CallOption) (*ListUserConnectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserConnectionsResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ListUserConnections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) SetConnectionLimit(ctx context.Context, in *SetConnectionLimitRequest, opts ...grpc.CallOption) (*SetConnectionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetConnectionLimitResponse)
	err := c.cc.Invoke(ctx, RateLimitService_SetConnectionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ClearConnectionLimit(ctx context.Context, in *ClearConnectionLimitRequest, opts ...grpc.CallOption) (*ClearConnectionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearConnectionLimitResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ClearConnectionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) GetActiveDevicesSnapshot(ctx context.Context, in *GetActiveDevicesSnapshotRequest, opts ...grpc.CallOption) (*GetActiveDevicesSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveDevicesSnapshotResponse)
	err := c.cc.Invoke(ctx, RateLimitService_GetActiveDevicesSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) PeekActiveDevicesSnapshot(ctx context.Context, in *GetActiveDevicesSnapshotRequest, opts ...grpc.CallOption) (*GetActiveDevicesSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveDevicesSnapshotResponse)
	err := c.cc.Invoke(ctx, RateLimitService_PeekActiveDevicesSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ListUserDevices(ctx context.Context, in *ListUserDevicesRequest, opts ...grpc.CallOption) (*ListUserDevicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserDevicesResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ListUserDevices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) SetDeviceLimit(ctx context.Context, in *SetDeviceLimitRequest, opts ...grpc.CallOption) (*SetDeviceLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDeviceLimitResponse)
	err := c.cc.Invoke(ctx, RateLimitService_SetDeviceLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ClearDeviceLimit(ctx context.Context, in *ClearDeviceLimitRequest, opts ...grpc.CallOption) (*ClearDeviceLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearDeviceLimitResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ClearDeviceLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) SetUserTotalLimit(ctx context.Context, in *SetUserTotalLimitRequest, opts ...grpc.CallOption) (*SetUserTotalLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserTotalLimitResponse)
	err := c.cc.Invoke(ctx, RateLimitService_SetUserTotalLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) GetUserStats(ctx context.Context, in *GetUserStatsRequest, opts ...grpc.CallOption) (*GetUserStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserStatsResponse)
	err := c.cc.Invoke(ctx, RateLimitService_GetUserStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) SetKeyMode(ctx context.Context, in *SetKeyModeRequest, opts ...grpc.CallOption) (*SetKeyModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetKeyModeResponse)
	err := c.cc.Invoke(ctx, RateLimitService_SetKeyMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) GetKeyMode(ctx context.Context, in *GetKeyModeRequest, opts ...grpc.CallOption) (*GetKeyModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKeyModeResponse)
	err := c.cc.Invoke(ctx, RateLimitService_GetKeyMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) SetGrace(ctx context.Context, in *SetGraceRequest, opts ...grpc.CallOption) (*SetGraceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetGraceResponse)
	err := c.cc.Invoke(ctx, RateLimitService_SetGrace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) GetGrace(ctx context.Context, in *GetGraceRequest, opts ...grpc.CallOption) (*GetGraceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGraceResponse)
	err := c.cc.Invoke(ctx, RateLimitService_GetGrace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ClearUserEgressCache(ctx context.Context, in *ClearUserEgressCacheRequest, opts ...grpc.CallOption) (*ClearUserEgressCacheResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearUserEgressCacheResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ClearUserEgressCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ClearUserDefaultPerConnLimit(ctx context.Context, in *ClearUserDefaultPerConnLimitRequest, opts ...grpc.CallOption) (*ClearUserDefaultPerConnLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearUserDefaultPerConnLimitResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ClearUserDefaultPerConnLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ClearUserConnOverrideLimits(ctx context.Context, in *ClearUserConnOverrideLimitsRequest, opts ...grpc.CallOption) (*ClearUserConnOverrideLimitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearUserConnOverrideLimitsResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ClearUserConnOverrideLimits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RateLimitServiceServer is the server API for RateLimitService service.
// All implementations must embed UnimplementedRateLimitServiceServer
// for forward compatibility.
type RateLimitServiceServer interface {
	// ---- existing (оставим для отладки/совместимости) ----
	SetUserDefaultPerConnLimit(context.Context, *SetUserDefaultPerConnLimitRequest) (*SetUserDefaultPerConnLimitResponse, error)
	ListUserConnections(context.Context, *ListUserConnectionsRequest) (*ListUserConnectionsResponse, error)
	SetConnectionLimit(context.Context, *SetConnectionLimitRequest) (*SetConnectionLimitResponse, error)
	ClearConnectionLimit(context.Context, *ClearConnectionLimitRequest) (*ClearConnectionLimitResponse, error)
	// Снимок всех активных "устройств" (uuid+src_ip) на ЭТОМ сервере.
	GetActiveDevicesSnapshot(context.Context, *GetActiveDevicesSnapshotRequest) (*GetActiveDevicesSnapshotResponse, error)
	PeekActiveDevicesSnapshot(context.Context, *GetActiveDevicesSnapshotRequest) (*GetActiveDevicesSnapshotResponse, error)
	// Список устройств конкретного пользователя (uuid) на ЭТОМ сервере.
	ListUserDevices(context.Context, *ListUserDevicesRequest) (*ListUserDevicesResponse, error)
	// Управление лимитом по "устройству" (device_key = uuid + "|" + src_ip).
	SetDeviceLimit(context.Context, *SetDeviceLimitRequest) (*SetDeviceLimitResponse, error)
	ClearDeviceLimit(context.Context, *ClearDeviceLimitRequest) (*ClearDeviceLimitResponse, error)
	// Установить ОБЩИЙ лимит для пользователя (UUID).
	// Лимит будет РАВНОМЕРНО поделен между всеми активными устройствами
	// этого UUID на данном сервере.
	SetUserTotalLimit(context.Context, *SetUserTotalLimitRequest) (*SetUserTotalLimitResponse, error)
	GetUserStats(context.Context, *GetUserStatsRequest) (*GetUserStatsResponse, error)
	SetKeyMode(context.Context, *SetKeyModeRequest) (*SetKeyModeResponse, error)
	GetKeyMode(context.Context, *GetKeyModeRequest) (*GetKeyModeResponse, error)
	SetGrace(context.Context, *SetGraceRequest) (*SetGraceResponse, error)
	GetGrace(context.Context, *GetGraceRequest) (*GetGraceResponse, error)
	ClearUserEgressCache(context.Context, *ClearUserEgressCacheRequest) (*ClearUserEgressCacheResponse, error)
	ClearUserDefaultPerConnLimit(context.Context, *ClearUserDefaultPerConnLimitRequest) (*ClearUserDefaultPerConnLimitResponse, error)
	ClearUserConnOverrideLimits(context.Context, *ClearUserConnOverrideLimitsRequest) (*ClearUserConnOverrideLimitsResponse, error)
	mustEmbedUnimplementedRateLimitServiceServer()
}

// UnimplementedRateLimitServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRateLimitServiceServer struct{}

func (UnimplementedRateLimitServiceServer) SetUserDefaultPerConnLimit(context.Context, *SetUserDefaultPerConnLimitRequest) (*SetUserDefaultPerConnLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetUserDefaultPerConnLimit not implemented")
}
func (UnimplementedRateLimitServiceServer) ListUserConnections(context.Context, *ListUserConnectionsRequest) (*ListUserConnectionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUserConnections not implemented")
}
func (UnimplementedRateLimitServiceServer) SetConnectionLimit(context.Context, *SetConnectionLimitRequest) (*SetConnectionLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetConnectionLimit not implemented")
}
func (UnimplementedRateLimitServiceServer) ClearConnectionLimit(context.Context, *ClearConnectionLimitRequest) (*ClearConnectionLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearConnectionLimit not implemented")
}
func (UnimplementedRateLimitServiceServer) GetActiveDevicesSnapshot(context.Context, *GetActiveDevicesSnapshotRequest) (*GetActiveDevicesSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetActiveDevicesSnapshot not implemented")
}
func (UnimplementedRateLimitServiceServer) PeekActiveDevicesSnapshot(context.Context, *GetActiveDevicesSnapshotRequest) (*GetActiveDevicesSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PeekActiveDevicesSnapshot not implemented")
}
func (UnimplementedRateLimitServiceServer) ListUserDevices(context.Context, *ListUserDevicesRequest) (*ListUserDevicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUserDevices not implemented")
}
func (UnimplementedRateLimitServiceServer) SetDeviceLimit(context.Context, *SetDeviceLimitRequest) (*SetDeviceLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDeviceLimit not implemented")
}
func (UnimplementedRateLimitServiceServer) ClearDeviceLimit(context.Context, *ClearDeviceLimitRequest) (*ClearDeviceLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearDeviceLimit not implemented")
}
func (UnimplementedRateLimitServiceServer) SetUserTotalLimit(context.Context, *SetUserTotalLimitRequest) (*SetUserTotalLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetUserTotalLimit not implemented")
}
func (UnimplementedRateLimitServiceServer) GetUserStats(context.Context, *GetUserStatsRequest) (*GetUserStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserStats not implemented")
}
func (UnimplementedRateLimitServiceServer) SetKeyMode(context.Context, *SetKeyModeRequest) (*SetKeyModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetKeyMode not implemented")
}
func (UnimplementedRateLimitServiceServer) GetKeyMode(context.Context, *GetKeyModeRequest) (*GetKeyModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetKeyMode not implemented")
}
func (UnimplementedRateLimitServiceServer) SetGrace(context.Context, *SetGraceRequest) (*SetGraceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetGrace not implemented")
}
func (UnimplementedRateLimitServiceServer) GetGrace(context.Context, *GetGraceRequest) (*GetGraceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGrace not implemented")
}
func (UnimplementedRateLimitServiceServer) ClearUserEgressCache(context.Context, *ClearUserEgressCacheRequest) (*ClearUserEgressCacheResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearUserEgressCache not implemented")
}
func (UnimplementedRateLimitServiceServer) ClearUserDefaultPerConnLimit(context.Context, *ClearUserDefaultPerConnLimitRequest) (*ClearUserDefaultPerConnLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearUserDefaultPerConnLimit not implemented")
}
func (UnimplementedRateLimitServiceServer) ClearUserConnOverrideLimits(context.Context, *ClearUserConnOverrideLimitsRequest) (*ClearUserConnOverrideLimitsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearUserConnOverrideLimits not implemented")
}
func (UnimplementedRateLimitServiceServer) mustEmbedUnimplementedRateLimitServiceServer() {}
func (UnimplementedRateLimitServiceServer) testEmbeddedByValue()                          {}

// UnsafeRateLimitServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RateLimitServiceServer will
// result in compilation errors.
type UnsafeRateLimitServiceServer interface {
	mustEmbedUnimplementedRateLimitServiceServer()
}

func RegisterRateLimitServiceServer(s grpc.ServiceRegistrar, srv RateLimitServiceServer) {
	// If the following call panics, it indicates UnimplementedRateLimitServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RateLimitService_ServiceDesc, srv)
}

func _RateLimitService_SetUserDefaultPerConnLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserDefaultPerConnLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).SetUserDefaultPerConnLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_SetUserDefaultPerConnLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).SetUserDefaultPerConnLimit(ctx, req.(*SetUserDefaultPerConnLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ListUserConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ListUserConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ListUserConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ListUserConnections(ctx, req.(*ListUserConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_SetConnectionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConnectionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).SetConnectionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_SetConnectionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).SetConnectionLimit(ctx, req.(*SetConnectionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ClearConnectionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearConnectionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ClearConnectionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ClearConnectionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ClearConnectionLimit(ctx, req.(*ClearConnectionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_GetActiveDevicesSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveDevicesSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).GetActiveDevicesSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_GetActiveDevicesSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).GetActiveDevicesSnapshot(ctx, req.(*GetActiveDevicesSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_PeekActiveDevicesSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveDevicesSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).PeekActiveDevicesSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_PeekActiveDevicesSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).PeekActiveDevicesSnapshot(ctx, req.(*GetActiveDevicesSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ListUserDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserDevicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ListUserDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ListUserDevices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ListUserDevices(ctx, req.(*ListUserDevicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_SetDeviceLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDeviceLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).SetDeviceLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_SetDeviceLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).SetDeviceLimit(ctx, req.(*SetDeviceLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ClearDeviceLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearDeviceLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ClearDeviceLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ClearDeviceLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ClearDeviceLimit(ctx, req.(*ClearDeviceLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_SetUserTotalLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserTotalLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).SetUserTotalLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_SetUserTotalLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).SetUserTotalLimit(ctx, req.(*SetUserTotalLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_GetUserStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).GetUserStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_GetUserStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).GetUserStats(ctx, req.(*GetUserStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_SetKeyMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).SetKeyMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_SetKeyMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).SetKeyMode(ctx, req.(*SetKeyModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_GetKeyMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).GetKeyMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_GetKeyMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).GetKeyMode(ctx, req.(*GetKeyModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_SetGrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).SetGrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_SetGrace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).SetGrace(ctx, req.(*SetGraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_GetGrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).GetGrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_GetGrace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).GetGrace(ctx, req.(*GetGraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ClearUserEgressCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearUserEgressCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ClearUserEgressCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ClearUserEgressCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ClearUserEgressCache(ctx, req.(*ClearUserEgressCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ClearUserDefaultPerConnLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearUserDefaultPerConnLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ClearUserDefaultPerConnLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ClearUserDefaultPerConnLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ClearUserDefaultPerConnLimit(ctx, req.(*ClearUserDefaultPerConnLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ClearUserConnOverrideLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearUserConnOverrideLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ClearUserConnOverrideLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ClearUserConnOverrideLimits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ClearUserConnOverrideLimits(ctx, req.(*ClearUserConnOverrideLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RateLimitService_ServiceDesc is the grpc.ServiceDesc for RateLimitService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RateLimitService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ratelimit.v1.RateLimitService",
	HandlerType: (*RateLimitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetUserDefaultPerConnLimit",
			Handler:    _RateLimitService_SetUserDefaultPerConnLimit_Handler,
		},
		{
			MethodName: "ListUserConnections",
			Handler:    _RateLimitService_ListUserConnections_Handler,
		},
		{
			MethodName: "SetConnectionLimit",
			Handler:    _RateLimitService_SetConnectionLimit_Handler,
		},
		{
			MethodName: "ClearConnectionLimit",
			Handler:    _RateLimitService_ClearConnectionLimit_Handler,
		},
		{
			MethodName: "GetActiveDevicesSnapshot",
			Handler:    _RateLimitService_GetActiveDevicesSnapshot_Handler,
		},
		{
			MethodName: "PeekActiveDevicesSnapshot",
			Handler:    _RateLimitService_PeekActiveDevicesSnapshot_Handler,
		},
		{
			MethodName: "ListUserDevices",
			Handler:    _RateLimitService_ListUserDevices_Handler,
		},
		{
			MethodName: "SetDeviceLimit",
			Handler:    _RateLimitService_SetDeviceLimit_Handler,
		},
		{
			MethodName: "ClearDeviceLimit",
			Handler:    _RateLimitService_ClearDeviceLimit_Handler,
		},
		{
			MethodName: "SetUserTotalLimit",
			Handler:    _RateLimitService_SetUserTotalLimit_Handler,
		},
		{
			MethodName: "GetUserStats",
			Handler:    _RateLimitService_GetUserStats_Handler,
		},
		{
			MethodName: "SetKeyMode",
			Handler:    _RateLimitService_SetKeyMode_Handler,
		},
		{
			MethodName: "GetKeyMode",
			Handler:    _RateLimitService_GetKeyMode_Handler,
		},
		{
			MethodName: "SetGrace",
			Handler:    _RateLimitService_SetGrace_Handler,
		},
		{
			MethodName: "GetGrace",
			Handler:    _RateLimitService_GetGrace_Handler,
		},
		{
			MethodName: "ClearUserEgressCache",
			Handler:    _RateLimitService_ClearUserEgressCache_Handler,
		},
		{
			MethodName: "ClearUserDefaultPerConnLimit",
			Handler:    _RateLimitService_ClearUserDefaultPerConnLimit_Handler,
		},
		{
			MethodName: "ClearUserConnOverrideLimits",
			Handler:    _RateLimitService_ClearUserConnOverrideLimits_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/ratelimit/api/ratelimit.proto",
}
